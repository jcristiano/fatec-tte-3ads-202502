---
sidebar_position: 1
title: Debate sobre a crise do software
---

import YouTubeEmbed from '@site/src/components/YouTubeEmbed';

# A Crise Perene e a Evolução da Engenharia de Software

A engenharia de software tem sido marcada por um ciclo contínuo de crises, evolução e novos desafios, culminando na situação atual de "regressão disfarçada de produtividade". Esta jornada nos leva desde os primórdios caóticos até a era da Inteligência Artificial (IA), que, apesar das promessas, introduziu novos problemas e exacerbou falhas antigas.

## Origens e a Primeira Crise do Software (Décadas de 1960 e 1970)

A disciplina de engenharia de software, como a conhecemos hoje, não existia formalmente antes da década de 1960. A programação era **manual**, feita em cartões perfurados ou diretamente em linguagens de máquina e Assembly, sendo **altamente propensa a erros**.

Em 1968, numa conferência da OTAN na Alemanha, os maiores especialistas da época cunharam o termo **"Crise do Software"**. As principais características dessa crise incluíam:
*   **Projetos atrasavam meses ou anos** e os orçamentos estouravam.
*   **Sistemas falhavam frequentemente** sem explicação clara.
*   O **código era uma "verdadeira bagunça"**, sem organização, padrões ou separação de responsabilidades.
*   A manutenção era um pesadelo, levando à mentalidade de **"Se funcionou, deixa assim"**.

As causas dessa crise original foram o **descompasso entre o avanço do hardware e a habilidade dos programadores** de organizarem o desenvolvimento, uma **crise de oferta** (demanda maior que a capacidade de desenvolvimento) e uma **crise de manutenção**. Percebeu-se que a "crise" não era temporária, mas sim um conjunto de **problemas perenes inerentes à complexidade do desenvolvimento de software**.

## A Era de Ouro: Busca por Ordem e Qualidade (Décadas de 1970 a 2000)

Em resposta ao caos, a década de 1970 marcou o início da formalização do desenvolvimento de software:
*   **Programação Estruturada**: Edsger Dijkstra denunciou o uso desenfreado do GOTO e propôs a **programação estruturada**, baseada em sequência, condição (if-else) e repetição (loop), visando um fluxo de programa previsível e legível.
*   **Encapsulamento de Decisões**: David Parnas introduziu o conceito de **esconder a complexidade interna** de um módulo de software, expondo apenas uma interface limpa.
*   **Linguagens de Programação**: Linguagens como Pascal, Algol, Modula e Ada surgiram, incentivando a clareza, modularização e legibilidade, enquanto Cobol, Fortran e Assembly ainda dominavam a indústria.

A década de 1980 viu a **Engenharia de Software** ganhar força como disciplina, tratando o software como algo que requer **arquitetura e engenharia**.
*   **Programação Orientada a Objetos (POO)**: Popularizada com C++ e Objective C, trouxe a ideia de **quebrar o software em partes menores, reutilizáveis e isoladas**, cada uma com uma única responsabilidade.
    *   Os pilares da POO incluem **encapsulamento, herança, polimorfismo e abstração**.
    *   A POO veio resolver problemas de modularidade, reusabilidade, manutenibilidade e escalabilidade.

Os anos 90 foram um período de **"boom" e padronização**.
*   **Design Patterns**: O livro *Design Patterns* (1994) catalogou 23 padrões de projeto (como Decorator, Factory, Strategy, Observer), criando um **"vocabulário universal"** e fornecendo soluções testadas para problemas comuns.
*   **Java**: Lançado em 1995, popularizou definitivamente a POO no mundo corporativo, tornando-se o **"padrão obrigatório do mercado"**.

A década de 2000 consolidou essa evolução, considerada por muitos a "era de ouro da engenharia de software":
*   **Princípios SOLID**: Robert Martin sintetizou conhecimentos para evitar código frágil, acoplado e bagunçado, promovendo um design de código consciente.
*   **Manifesto Ágil**: Criado em 2001, trouxe alternativas mais **flexíveis, colaborativas e focadas na entrega de valor**.
*   **Domain-Driven Design (DDD)**: Proposto em 2003 por Eric Evans, defendendo o foco no **domínio do negócio**.
*   **Clean Code**: Publicado em 2008, defendendo código limpo, funções pequenas e responsabilidades bem definidas.
*   **Object Calisthenics**: Jeff Bay trouxe nove regras de ouro para forçar um código coeso e desacoplado.

## Novos Vilões e a Crise de Significado

Apesar da excelência técnica alcançada, novos problemas surgiram:
*   **Overengineering**: Excesso de engenharia e complexidade desnecessária, quando princípios viraram dogmas e padrões se tornaram obrigações.
*   **Crise de Significado**: No século XXI, a abundância de fatos e escassez de compreensão resultou em alto *turnover* e perda de propósito.
*   **Underengineering**: A corrida por velocidade e a distorção das metodologias ágeis levaram ao **sacrífico da arquitetura e da qualidade** em prol da entrega.

## A Era da IA e a "Cracolândia Digital"

A mais recente reviravolta veio com a ascensão da Inteligência Artificial Generativa:
*   **Promessas da IA**: Ferramentas como GitHub Copilot e ChatGPT surgiram, prometendo gerar código e explicar soluções.
*   **Efeitos Colaterais**: Problemas como **código duplicado, vulnerabilidades e soluções frágeis** começaram a aparecer.
*   **A "Mediocridade Regurgitada"**: A IA foi treinada em grande parte com códigos de qualidade duvidosa, replicando práticas ruins.
*   **"Vibe Coding"**: Nova geração de programadores que terceiriza o raciocínio para a IA, sem se preocupar com lógica, arquitetura ou qualidade.
*   **Consequência Atual**: O código nas empresas está se tornando uma "colcha de retalhos imprevisível", difícil de manter e refatorar, criando um ciclo de mediocridade que pode levar a uma **nova crise do software**.

## O Caminho à Frente: Responsabilidade e Conhecimento

Para resgatar a engenharia de software, é crucial entender que a profissão de programador não será destruída pela IA, mas sim pela **preguiça e pela falta de responsabilidade técnica**.  
O futuro envolve:
*   **Resgatar a responsabilidade técnica**.
*   **Voltar a estudar os fundamentos**.
*   Desenvolver **pensamento crítico**.
*   Ter **rigor e clareza ao escrever código**.
*   Compreender o **impacto do software em sistemas críticos**.
*   Buscar o **significado por trás dos fatos**, conectando-se ao propósito do negócio.
*   Equilibrar **estratégia e arquitetura**, buscando sempre a simplicidade.

## Video referência

<YouTubeEmbed videoId="oDXDYjksMds" />


## Material complementar

| Título do Material                  | Tipo   | Link |
|------------------------------------|--------|------|
| Apresentação em sala de aula | PDF    | [Download](./pdf/A-Crise-Evolucao-e-o-Futuro-da-Engenharia-de-Software.pdf) |
| Crise do software | PDF    | [Download](./pdf/aula02__produtos_artefatos_processos_cmm_2017.pdf) |
| Artigo: Da crise do software à crise de significado: a importância de aprender a compreender | PDF    | [Download](./pdf/apresender_a_compreender.pdf) |
